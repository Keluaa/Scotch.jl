var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Scotch","category":"page"},{"location":"#Scotch","page":"Home","title":"Scotch","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Scotch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The official SCOTCH user manual is referenced everywhere is this documentation. You can get the manual from the official GitLab.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Any SCOTCH function of the C library used within the wrapper is mentioned here. Therefore you can search any SCOTCH function from this page to know what its Julia equivalent is.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All names starting with SCOTCH_ are part of the C library. You can access all symbols defined in the C library through Scotch.LibScotch.","category":"page"},{"location":"#Strategy","page":"Home","title":"Strategy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Strat\nstrat_alloc\nstrat_flags\nstrat\nstrat_build","category":"page"},{"location":"#Scotch.Strat","page":"Home","title":"Scotch.Strat","text":"Strat\n\nWrapper around a SCOTCH_Strat pointer.\n\n\n\n\n\n","category":"type"},{"location":"#Scotch.strat_alloc","page":"Home","title":"Scotch.strat_alloc","text":"strat_alloc()\n\nAllocate a new Strat with SCOTCH_stratAlloc, then initialize it with SCOTCH_stratInit.\n\nFinalizers will properly call SCOTCH_stratExit then SCOTCH_memFree once unused.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.strat_flags","page":"Home","title":"Scotch.strat_flags","text":"strat_flags(; strategy=:default,\n    recursive=false, remap=false,\n    disconnected=false, level_max=false, level_min=false, leaf_simple=false, sepa_simple=false\n)\n\nReturn a flag value (mentionned as flagval in the SCOTCH manual) depending on the given flags.\n\nAvailable straegies are: :default, :balance, :quality, :safety and :speed.\n\nSee the section 8.3.1 of the manual for their corresponding meaning.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.strat","page":"Home","title":"Scotch.strat","text":"strat(type::Symbol, strategy::AbstractString)\n\nAllocate and initialize a new Strat from the given strategy string.\n\ntype is the strategy type:\n\n:graph_bipart uses SCOTCH_stratGraphBipart\n:graph_map uses SCOTCH_stratGraphMap\n:graph_part_overlap uses SCOTCH_stratGraphPartOvl\n:graph_order uses SCOTCH_stratGraphOrder\n:mesh_order uses SCOTCH_stratMeshOrder\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.strat_build","page":"Home","title":"Scotch.strat_build","text":"strat_build(type::Symbol;\n    imbalance_ratio::Float64=0.0, parts=0,\n    max_cluster_weight=0, min_edge_density=0.0, level_nbr=0,\n    strategy=:default, kwargs...\n)\n\nAllocate and initialize a new Strat from the given parameters. Not all of them are used for every type, see the manual for more info.\n\nstrategy and kwargs are passed to strat_flags.\n\ntype is the strategy type:\n\n:graph_bipart uses SCOTCH_stratGraphClusterBuild\n:graph_map uses SCOTCH_stratGraphMapBuild\n:graph_part_overlap uses SCOTCH_stratGraphPartOvlBuild\n:graph_order uses SCOTCH_stratGraphOrderBuild\n:mesh_order uses SCOTCH_stratMeshOrderBuild\n\n\n\n\n\n","category":"function"},{"location":"#Architecture","page":"Home","title":"Architecture","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Arch\narch_alloc\narch_load\narch_size\narch_name\narch_build\narch_complete_graph\narch_hypercube\narch_mesh\narch_torus\narch_tree\narch_subset","category":"page"},{"location":"#Scotch.Arch","page":"Home","title":"Scotch.Arch","text":"Arch\n\nWrapper around a SCOTCH_Arch pointer.\n\n\n\n\n\n","category":"type"},{"location":"#Scotch.arch_alloc","page":"Home","title":"Scotch.arch_alloc","text":"arch_alloc()\n\nAllocate a new Arch with SCOTCH_archAlloc, then initialize it with SCOTCH_archInit.\n\nFinalizers will properly call SCOTCH_archExit then SCOTCH_memFree once unused.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_load","page":"Home","title":"Scotch.arch_load","text":"arch_load(filename::AbstractString)    \narch_load(file::IO)\n\nLoad a new Arch from the given file. See SCOTCH_archLoad.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_size","page":"Home","title":"Scotch.arch_size","text":"arch_size(arch::Arch)\n\nNumber of nodes in arch. See SCOTCH_archSize.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_name","page":"Home","title":"Scotch.arch_name","text":"arch_name(arch::Arch)\n\nName of arch. See SCOTCH_archName.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_build","page":"Home","title":"Scotch.arch_build","text":"arch_build(graph::Graph; restrain=nothing)\n\nAllocate and initialize a new Arch with SCOTCH_archBuild2.\n\nrestrain may be a Vector{SCOTCH_Num} of indices of graph nodes.\n\n\n\n\n\narch_build(graph::Graph, strat::Strat; target=:default, restrain=nothing)\n\nAllocate and initialize a new Arch using strategy for the given target:\n\n:default uses SCOTCH_archBuild\n:deco_1 uses SCOTCH_archBuild0\n:deco_2 uses SCOTCH_archBuild2\n\nrestrain may be a Vector{SCOTCH_Num} of indices of graph nodes.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_complete_graph","page":"Home","title":"Scotch.arch_complete_graph","text":"arch_complete_graph(n_vertices; weights=nothing, variable=false)\n\nAllocate and initialize a new Arch for a complete graph topology with SCOTCH_archCmplt, SCOTCH_archCmpltw or SCOTCH_archVcmplt.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_hypercube","page":"Home","title":"Scotch.arch_hypercube","text":"arch_hypercube(dim; variable=false)\n\nAllocate and initialize a new Arch for a hypercube topology with SCOTCH_archHcub or SCOTCH_archVhcub.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_mesh","page":"Home","title":"Scotch.arch_mesh","text":"arch_mesh(dimensions::Vector{SCOTCH_Num})\n\nAllocate and initialize a new Arch for a mesh topology with SCOTCH_archMeshX.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_torus","page":"Home","title":"Scotch.arch_torus","text":"arch_torus(dimensions::Vector{SCOTCH_Num})\n\nAllocate and initialize a new Arch for a torus topology with SCOTCH_archTorusX.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_tree","page":"Home","title":"Scotch.arch_tree","text":"arch_tree(levels::Vector{SCOTCH_Num}, link_cost::Vector{SCOTCH_Num})\n\nAllocate and initialize a new Arch for a tree topology with SCOTCH_archTleaf.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.arch_subset","page":"Home","title":"Scotch.arch_subset","text":"arch_subset(arch::Arch, processors::Vector{SCOTCH_Num})\n\nAllocate and initialize a new Arch from a subset of arch including processors with SCOTCH_archSub.\n\n\n\n\n\n","category":"function"},{"location":"#Graph","page":"Home","title":"Graph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Graph\ngraph_alloc\ngraph_size\ngraph_build\ngraph_base_index\ngraph_base_index!\ngraph_data\ngraph_dump\ngraph_load\ngraph_coarsen\ngraph_coarsen_match\ngraph_color\ngraph_diameter\ngraph_induce\ngraph_stat","category":"page"},{"location":"#Scotch.Graph","page":"Home","title":"Scotch.Graph","text":"Graph\n\nWrapper around a SCOTCH_Graph pointer.\n\nReferences to the arrays which may have been used to build the graph are stored in the struct, preventing them from being GC'ed by Julia.\n\n\n\n\n\n","category":"type"},{"location":"#Scotch.graph_alloc","page":"Home","title":"Scotch.graph_alloc","text":"graph_alloc()\n\nAllocate a new Graph with SCOTCH_graphAlloc, then initialize it with SCOTCH_graphInit.\n\nFinalizers will properly call SCOTCH_graphExit then SCOTCH_memFree once unused.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_size","page":"Home","title":"Scotch.graph_size","text":"graph_size(graph::Graph)\n\nNumber of vertices and edges (arcs) of the graph.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_build","page":"Home","title":"Scotch.graph_build","text":"graph_build(\n    adj_index::Vector{SCOTCH_Num}, adj_array::Vector{SCOTCH_Num};\n    index_start=1, check=true,\n    adj_idx_end::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    v_weights::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    e_weights::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    labels::Union{Vector{SCOTCH_Num}, Nothing}=nothing\n)\n\nAllocate and initialize a new Graph using SCOTCH_graphBuild.\n\nIf check == true, then SCOTCH_graphCheck may throw an error if the graph is invalid.\n\nIf adj_idx_end is given, adj_index is considered to be non-compact.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_base_index","page":"Home","title":"Scotch.graph_base_index","text":"graph_base_index(graph::Graph)\n\nReturn the base index of graph, using SCOTCH_graphData.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_base_index!","page":"Home","title":"Scotch.graph_base_index!","text":"graph_base_index!(graph::Graph, base_idx)\n\nSets the base index of graph using SCOTCH_graphBase\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_data","page":"Home","title":"Scotch.graph_data","text":"graph_data(graph::Graph)\n\nReturns a NamedTuple containing:\n\n(;\n    index_start, n_vertices, n_arcs, n_edges,\n    adj_idx, adj_idx_end, vertices_weights,\n    vertices_labels, adj_array, arcs_weights\n)\n\nArrays are either nothing or wrapped into a Vector{SCOTCH_Num}. They share the data with the underlying graph.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_dump","page":"Home","title":"Scotch.graph_dump","text":"graph_dump(graph::Graph, filename::AbstractString, name_prefix::AbstractString, name_suffix::AbstractString)\n\nUse SCOTCH_graphDump to dump the graph to filename.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_load","page":"Home","title":"Scotch.graph_load","text":"graph_load(file::IO; index_start=nothing, vertex_weights=true, edge_weights=true)\ngraph_load(filename::AbstractString; kwargs...)\n\nLoad a new Graph from file with SCOTCH_graphLoad.\n\nIf index_start == nothing, then the base indexing of the file is conserved.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_coarsen","page":"Home","title":"Scotch.graph_coarsen","text":"graph_coarsen(fine_graph::Graph, n_vertices, coarsening_ratio;\n    no_merge=false, coarse_multi_nodes::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    fine_mates::Union{Vector{SCOTCH_Num}, Nothing}=nothing\n)\n\nCoarsen fine_graph into a new Graph with n_vertices at maximum. Returns (coarse_graph, coarse_multi_nodes), or (nothing, nothing) if the coarsening failed.\n\nno_merge sets the SCOTCH_COARSENNOMERGE flag.\n\nIf fine_mates is given, SCOTCH_graphCoarsenBuild is used, SCOTCH_graphCoarsen otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_coarsen_match","page":"Home","title":"Scotch.graph_coarsen_match","text":"graph_coarsen_match(fine_graph::Graph, n_vertices, coarsening_ratio;\n    no_merge=false, fine_mates::Union{Vector{SCOTCH_Num}, Nothing}=nothing\n)\n\nFill fine_mates using SCOTCH_graphCoarsenMatch Returns (n_vertices, fine_mates), or (nothing, nothing) if the coarsening failed.\n\nno_merge sets the SCOTCH_COARSENNOMERGE flag.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_color","page":"Home","title":"Scotch.graph_color","text":"graph_color(graph::Graph; colors::Union{Vector{SCOTCH_Num}, Nothing}=nothing)\n\nCompute a coloring of the graph using SCOTCH_graphColor. Returns (n_colors, colors).\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_diameter","page":"Home","title":"Scotch.graph_diameter","text":"graph_diameter(graph::Graph)\n\nDiameter of the graph, using SCOTCH_graphDiamPV.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_induce","page":"Home","title":"Scotch.graph_induce","text":"graph_induce(graph::Graph, keep_vertices::Vector{SCOTCH_Num})\n\nA new [Graph] induced from graph by keeping the vertices in keep_vertices, using SCOTCH_graphInduceList.\n\n\n\n\n\ngraph_induce(graph::Graph, vertices_part::Vector{SCOTCH_GraphPart2}, keep_part::SCOTCH_GraphPart2)\n\nA new [Graph] induced from graph by keeping the vertices for which vertices_part matches keep_part, using SCOTCH_graphInducePart.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_stat","page":"Home","title":"Scotch.graph_stat","text":"graph_stat(graph::Graph)\n\nStatistics about the graph: returns (; vertex_load, edge_load, vertex_degree). Each value contains the following fields: min, max, sum (not for vertex_degree), avg (average) and var (standard deviation).\n\n\n\n\n\n","category":"function"},{"location":"#Mapping-and-partitioning","page":"Home","title":"Mapping and partitioning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"graph_map\ngraph_remap\ngraph_part\ngraph_repart","category":"page"},{"location":"#Scotch.graph_map","page":"Home","title":"Scotch.graph_map","text":"graph_map(graph::Graph, arch::Arch, strat::Strat; partition=nothing, fixed=false)\n\nMap graph to arch with strat using SCOTCH_graphMap. Returns partition while conserving the base index of the graph.\n\nIf fixed == true, then partition gives the fixed vertices and SCOTCH_graphMapFixed is used instead.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_remap","page":"Home","title":"Scotch.graph_remap","text":"graph_remap(\n    graph::Graph, arch::Arch, old_partition::Vector{SCOTCH_Num},\n    cost_factor::Float64, costs::Vector{SCOTCH_Num}, strat::Strat;\n    partition=nothing, fixed=false\n)\n\nCompute a mapping from an old_partition, costs and cost_factor, using SCOTCH_graphRemap. Returns partition while conserving the base index of the graph.\n\nIf fixed == true, then partition gives the fixed vertices and `SCOTCH_graphRemapFixed is used instead.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_part","page":"Home","title":"Scotch.graph_part","text":"graph_part(graph::Graph, parts, strat::Strat; partition=nothing, fixed=false, overlap=false)\n\nPartitions the graph into parts, with the given strategy, using SCOTCH_graphPart. Returns partition while conserving the base index of the graph.\n\nIf fixed == true, then partition gives the fixed vertices and `SCOTCH_graphPartFixed is used instead.\n\nIf overlap == true, then SCOTCH_graphPartOvl is used instead.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.graph_repart","page":"Home","title":"Scotch.graph_repart","text":"graph_repart(\n    graph::Graph, parts, old_partition::Vector{SCOTCH_Num},\n    cost_factor::Float64, costs::Vector{SCOTCH_Num}, strat::Strat;\n    partition=nothing, fixed=false\n)\n\nRe-partitions the graph into parts, with the old_partition, costs and cost_factor, using SCOTCH_graphRepart. Returns partition while conserving the base index of the graph.\n\nIf fixed == true, then partition gives the fixed vertices and `SCOTCH_graphPartFixed is used instead.\n\n\n\n\n\n","category":"function"},{"location":"#Mesh","page":"Home","title":"Mesh","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mesh\nmesh_alloc\nmesh_build\nmesh_data\nmesh_load\nmesh_graph\nmesh_size\nmesh_stat","category":"page"},{"location":"#Scotch.Mesh","page":"Home","title":"Scotch.Mesh","text":"Mesh\n\nWrapper around a SCOTCH_Mesh pointer.\n\nReferences to the arrays which may have been used to build the mesh are stored in the struct, preventing them from being GC'ed by Julia.\n\n\n\n\n\n","category":"type"},{"location":"#Scotch.mesh_alloc","page":"Home","title":"Scotch.mesh_alloc","text":"mesh_alloc()\n\nAllocate a new Mesh with SCOTCH_meshAlloc, then initialize it with SCOTCH_meshInit.\n\nFinalizers will properly call SCOTCH_meshExit then SCOTCH_memFree once unused.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.mesh_build","page":"Home","title":"Scotch.mesh_build","text":"mesh_build(adj_index::Vector{SCOTCH_Num}, adj_array::Vector{SCOTCH_Num}, elem_count, node_count;\n    index_start_element=1, index_start_node=1, check=true, arc_count=length(adj_array),\n    adj_index_end::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    element_load ::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    vertex_load  ::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n    vertex_labels::Union{Vector{SCOTCH_Num}, Nothing}=nothing,\n)\n\nAllocate and initialize a new Mesh using SCOTCH_meshBuild.\n\narc_count is twice the number of edges. The default value assumes that adj_array is compact.\n\nIf check == true, then SCOTCH_meshCheck may throw an error if the mesh is invalid.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.mesh_data","page":"Home","title":"Scotch.mesh_data","text":"mesh_data(mesh::Mesh)\n\nReturns a NamedTuple containing:\n\n(;\n    base_element_index, base_node_index,\n    n_elements, n_nodes, n_arcs, n_edges,\n    adj_idx, adj_idx_end,\n    elements_weights, nodes_weights, vertex_labels,\n    adj_array,\n    max_vertex_degree\n)\n\nArrays are either nothing or wrapped into a Vector{SCOTCH_Num}. They share the data with the underlying mesh.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.mesh_load","page":"Home","title":"Scotch.mesh_load","text":"mesh_load(file::IO; index_start=nothing)\nmesh_load(filename::AbstractString; kwargs...)\n\nLoad a new Mesh from file with SCOTCH_meshLoad.\n\nIf index_start == nothing, then the base indexing of the file is conserved.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.mesh_graph","page":"Home","title":"Scotch.mesh_graph","text":"mesh_graph(mesh::Mesh; dual=false, n_com=2)\n\nCreate a new Graph from the mesh using SCOTCH_meshGraph.\n\nIf dual == true, then SCOTCH_meshGraphDual is used instead, with n_com being the minimum number of shared mesh elements for an edge to be created being two vertices.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.mesh_size","page":"Home","title":"Scotch.mesh_size","text":"mesh_size(mesh::Mesh)\n\nReturns the number of (; elements, nodes, edges) for the mesh, using SCOTCH_meshSize.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.mesh_stat","page":"Home","title":"Scotch.mesh_stat","text":"mesh_stat(mesh::Mesh)\n\nStatistics about the mesh: returns (; node_load, element_degree, node_degree). Each value contains the following fields: min, max, sum (only for node_load), avg (average) and var (standard deviation).\n\n\n\n\n\n","category":"function"},{"location":"#Block-ordering","page":"Home","title":"Block ordering","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"block_ordering","category":"page"},{"location":"#Scotch.block_ordering","page":"Home","title":"Scotch.block_ordering","text":"block_ordering(graph_or_mesh::Union{Graph, Mesh}, strat::Strat;\n    permutation    ::Union{Bool, Nothing, Vector{SCOTCH_Num}}=nothing,\n    inv_permutation::Union{Bool, Nothing, Vector{SCOTCH_Num}}=nothing,\n    columns        ::Union{Bool, Nothing, Vector{SCOTCH_Num}}=nothing,\n    separators_tree::Union{Bool, Nothing, Vector{SCOTCH_Num}}=nothing\n)\n\nCompute a block ordering of the graph or mesh using SCOTCH_graphOrder or SCOTCH_meshOrder. Returns (permutation, inv_permutation, num_blocks, columns, separators_tree).\n\npermutation, inv_permutation, columns or separators_tree can have 3 values each:\n\nnothing: converted to C_NULL and subsequantly ignored\ntrue: a new vector of the appropriate size is allocated and returned\na Vector{SCOTCH_Num}: used and returned without allocation\n\n\n\n\n\n","category":"function"},{"location":"#Context","page":"Home","title":"Context","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Context\ncontext_alloc\nrandom_clone\nrandom_seed(::Context, ::Any)\nrandom_reset(::Context)\ncontext_option\ncontext_option!\nbind_graph\nbind_mesh","category":"page"},{"location":"#Scotch.Context","page":"Home","title":"Scotch.Context","text":"Context\n\nWrapper around a SCOTCH_Context pointer.\n\n\n\n\n\n","category":"type"},{"location":"#Scotch.context_alloc","page":"Home","title":"Scotch.context_alloc","text":"context_alloc()\n\nAllocate a new Context with SCOTCH_contextAlloc, then initialize it with SCOTCH_contextInit.\n\nFinalizers will properly call SCOTCH_contextExit then SCOTCH_memFree once unused.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.random_clone","page":"Home","title":"Scotch.random_clone","text":"random_clone(ctx::Context)\n\nClone the global RNG state into ctx using SCOTCH_contextRandomClone.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.random_seed-Tuple{Scotch.Context, Any}","page":"Home","title":"Scotch.random_seed","text":"random_seed(ctx::Context, seed)\n\nSet the RNG seed of ctx using SCOTCH_contextRandomSeed.\n\n\n\n\n\n","category":"method"},{"location":"#Scotch.random_reset-Tuple{Scotch.Context}","page":"Home","title":"Scotch.random_reset","text":"random_reset(ctx::Context)\n\nResets the RNG of ctx using SCOTCH_contextRandomReset.\n\n\n\n\n\n","category":"method"},{"location":"#Scotch.context_option","page":"Home","title":"Scotch.context_option","text":"context_option(ctx::Context, option::Symbol)\n\nGet the option for ctx to value using SCOTCH_contextOptionGetNum.\n\noption can be:\n\n:deterministic for SCOTCH_OPTIONNUMDETERMINISTIC\n:fixed_seed for SCOTCH_OPTIONNUMRANDOMFIXEDSEED\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.context_option!","page":"Home","title":"Scotch.context_option!","text":"context_option!(ctx::Context, option::Symbol, value::Bool)\n\nSet the option for ctx to value using SCOTCH_contextOptionSetNum.\n\noption can be:\n\n:deterministic for SCOTCH_OPTIONNUMDETERMINISTIC\n:fixed_seed for SCOTCH_OPTIONNUMRANDOMFIXEDSEED\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.bind_graph","page":"Home","title":"Scotch.bind_graph","text":"bind_graph(ctx::Context, graph::Graph)\n\nCreate a new Graph from graph bound to ctx using SCOTCH_contextBindGraph.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.bind_mesh","page":"Home","title":"Scotch.bind_mesh","text":"bind_graph(ctx::Context, mesh::Mesh)\n\nCreate a new Graph from mesh bound to ctx using SCOTCH_contextBindGraph.\n\n\n\n\n\n","category":"function"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"save\nrandom_seed(::Any)\nrandom_reset()\nversion","category":"page"},{"location":"#Scotch.save","page":"Home","title":"Scotch.save","text":"save(obj, filename::AbstractString)\n\nSaves obj to the given filename.\n\n\n\n\n\nsave(strat::Strat, file::IO)\n\nSave the strat to file.\n\n\n\n\n\nsave(arch::Arch, file::IO)\n\nSave the arch to file using SCOTCH_archSave.\n\n\n\n\n\nsave(graph::Graph, file::IO)\n\nSave the graph to file using SCOTCH_graphSave.\n\n\n\n\n\nsave(mesh::Mesh, file::IO)\n\nSave the mesh to file using SCOTCH_meshSave.\n\n\n\n\n\n","category":"function"},{"location":"#Scotch.random_seed-Tuple{Any}","page":"Home","title":"Scotch.random_seed","text":"random_seed(seed)\n\nSets the global RNG seed using SCOTCH_randomSeed.\n\n\n\n\n\n","category":"method"},{"location":"#Scotch.random_reset-Tuple{}","page":"Home","title":"Scotch.random_reset","text":"random_reset()\n\nResets the global RNG seed using SCOTCH_randomReset.\n\n\n\n\n\n","category":"method"},{"location":"#Scotch.version","page":"Home","title":"Scotch.version","text":"version()\n\nThe version of the loaded SCOTCH library. Calls SCOTCH_version.\n\n\n\n\n\n","category":"function"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SCOTCH_Num\nSCOTCH_GraphPart2","category":"page"},{"location":"#Scotch.LibScotch.SCOTCH_Num","page":"Home","title":"Scotch.LibScotch.SCOTCH_Num","text":"SCOTCH_Num\n\nInteger type (should be a Cint/Int32 on most machines).\n\n\n\n\n\n","category":"type"},{"location":"#Scotch.LibScotch.SCOTCH_GraphPart2","page":"Home","title":"Scotch.LibScotch.SCOTCH_GraphPart2","text":"SCOTCH_GraphPart2\n\nSmall integer type (should be a Cuchar/UInt8 on most machines).\n\n\n\n\n\n","category":"type"}]
}
